# Bindings

Created on 2022-06-14 by Mateusz Szostok ([@mszostok](https://github.com/mszostok))

<!-- toc -->

- [Motivation](#motivation)
  * [Goal](#goal)
  * [Non-goal](#non-goal)
- [Proposal](#proposal)
  * [Overview](#overview)
  * [Use case: Route BotKube notifications to individual channels](#use-case-route-botkube-notifications-to-individual-channels)
  * [Use case: Send notifications to multiple sinks](#use-case-send-notifications-to-multiple-sinks)
  * [Use case: Route notifications to a given channel based on the Kubernetes Namespace](#use-case--route-notifications-to-a-given-channel-based-on-the-kubernetes-namespace)
  * [Use case: Run executor only from a dedicated channel](#use-case-run-executor-only-from-a-dedicated-channel)
  * [Others](#others)
- [Alternatives](#alternatives)
  * [Route notifications to a given channel based on the Kubernetes Namespace](#route-notifications-to-a-given-channel-based-on-the-kubernetes-namespace)
    + [Annotate Namespace](#annotate-namespace)
    + [Top level Namespace property](#top-level-namespace-property)
- [Consequences](#consequences)
  * [Minimum changes](#minimum-changes)
  * [Follow-up changes](#follow-up-changes)
  * [Syntax](#syntax)
- [Resources](#resources)

<!-- tocstop -->

## Motivation

There is a demand in community to make the configuration more flexible in regards which notification should be collected and where to send.

The proposed syntax not only enables new features, but also addresses the issues described in the **Configuration API syntax issues** investigation document.

### Goal

1. Routing notifications to individual channels without needing to run multiple deployments. Example use cases:
    - a separate Slack channel for sending network errors and another channel for all error events that occur in the team-a Namespace
    - sending Pod's error events to Slack and, at the same time, notifying Elasticsearch of all events

    Related issues:
      - [Support communications per resource group](https://github.com/infracloudio/botkube/issues/508)
      - [Support using multiple Slack channels with different configuration](https://github.com/infracloudio/botkube/issues/444)
      - [Provide multiple channels](https://github.com/infracloudio/botkube/issues/542)

2. Route notifications to a given channel based on the Kubernetes Namespace.

    Related issues:
      - [Define the channel at the namespace level](https://github.com/infracloudio/botkube/issues/486)

3. Defining `kubectl` (executor) permissions per channelâ€”in particular, configuring what commands can be executed and in which Namespaces.

    Currently, it's possible only if you will deploy multiple BotKube instances with different configurations.

    Related issues:
      - [Multiple Slack Channels](https://github.com/infracloudio/botkube/issues/250)

### Non-goal

Those are not the goals of this proposal. However, we should be able to implement them later.
- [Notify groups](https://github.com/infracloudio/botkube/issues/323)
- [Group error messages to thread](https://github.com/infracloudio/botkube/issues/545)
- [Customizable Messages](https://github.com/infracloudio/botkube/issues/434)
- [Support for default cluster and namespace on any Slack channels](https://github.com/infracloudio/botkube/issues/421)

## Proposal

### Overview

This idea is to explicitly extract such configuration domains:
- Executors, such as `kubectl`, `helm`, `istioctl` etc.
- Notifiers, such as Kubernetes events, Sysdig, Prometheus, etc.
- Communications, such as Slack, Discord, MS Teams etc.

1. New communications syntax.
    ```yaml
    communications: # allows to have multiple slacks, or ES configurations
      - name: tenant-workspace
        slack:
          token: 'SLACK_API_TOKEN'
          # ...trimmed...

          # describe channel bindings
          channels:
            - name: "#nodes"
              bindings:
                notifiers:
                  - "nodes-errors"
                  - "depreacted-api"
                executors:
                  - "kubectl-read-only"
                  - "helm-full-access"
        elasticsearch:
          server: 'ELASTICSEARCH_ADDRESS'
          # ...trimmed...

          # describe index bindings
          index:
            - destination:
                name: network-errors
                type: botkube-event
                shards: 1
              bindings:
                notifiers:
                  - "nodes-errors"
                  - "depreacted-api"
                # executors - not allowed in this case, ES is "sink" only.
    ```

2. New executor syntax.
     ```yaml
    executors:
      - name: kubectl-read-only # name used for bindings
        kubectl:
          # New 'namespace' property, allows Namespace restriction
          namespaces:
            include:
              - team-a
          commands:
            verbs: ["api-resources", "...", "auth"]
            resources: ["deployments", "..", "nodes"]
      - name: helm-full-access # name used for bindings
        helm:
          # New 'namespace' property, allows Namespace restriction
          namespaces:
            include:
              - team-a
          commands:
            verbs: ["list", "delete", "install"]
    ```

3. New notifier syntax.
     ```yaml
     notifiers:
       - name: nodes-errors # name used for bindings
         kubernetes:
           # New 'namespace' property, allows Namespace restriction
           # It can be overridden in nested level.
           namespace:
             include: ["@all"]
           resources:
             - name: v1/pods
               namespaces: # override top level namespace
                 include:
                   - istio-system
               events:
                 - error
             - name: networking.istio.io/v1alpha3/VirtualServices
               # uses the default Namespace settings from top level definition.
               events:
                 - error
         sysdig:
           # ..
         kubePug:
           # ...
     ```

### Use case: Route BotKube notifications to individual channels

With presented configuration:
- nodes errors are sent to a `#nodes` channel,
- while networks errors are sent to the `#network` channel.

**Communicators**

```yaml
communications: # allows to have multiple slacks, or ES configurations
  - name: tenant-workspace
    slack:
      token: 'SLACK_API_TOKEN'
      # customized notifications
      channels:
        - name: "#nodes"
          bindings:
            notifiers:
              - "nodes-errors"
        - name: "#network"
          bindings:
            notifiers:
              - "network-errors"
```

**Notifiers**

```yaml
notifiers:
 - name: nodes-errors # name used for bindings
   kubernetes:
     resources:
       - name: v1/nodes
         namespaces:
           include:
             - @all
         events:
           - error
  - name: network-errors
    kubernetes:
      namespace:
        include: ["@all"]
      resources:
        - name: v1/pods
          namespaces: # override top level namespace
            include:
              - istio-system
          events:
            - error
        - name: v1/services
          events:
            - error
        - name: networking.istio.io/v1alpha3/DestinationRules
          events:
            - error
        - name: networking.istio.io/v1alpha3/VirtualServices
          events:
            - error
```

### Use case: Send notifications to multiple sinks

With presented configuration:
- nodes events are sent to the `#nodes` channel,
- network and nodes errors to the `#all` channel,
- and at the same time network errors are sent to Elasticsearch.

**Communicators**

```yaml
communications:
  - name: tenant-workspace
    slack:
      token: 'SLACK_API_TOKEN'
      channels:
        - name: "#nodes"
          bindings:
            notifiers:
              - nodes-errors
            executors:
              - kubectl-full-access
        - name: "#all"
          bindings:
            notifiers:
              - network-errors
              - nodes-errors
            executors:
              - kubectl-full-access
    elasticsearch:
      server: 'ELASTICSEARCH_ADDRESS'
      index:
        - destination:
            name: network-errors
            type: botkube-event
            shards: 1
          bindings:
            notifiers:
              - network-errors
```

**Notifiers**
```yaml
notifiers:
  - name: nodes-errors
    kubernetes:
      resources:
        - name: v1/nodes
          namespaces:
            include: ["@all"]
          events:
            - error
  - name: network-errors
    kubernetes:
      namespaces:
        include: ["@all"]
      resources:
        - name: v1/services
          events:
            - error
        - name: networking.k8s.io/v1/ingresses
          events:
            - error
```

**Executors**
```yaml
executors:
  - name: kubectl-full-access
    kubectl:
      namespaces:
        include: ["@all"]
      commands:
        verbs: ["get", "...", "logs"]
        resources: ["Deployments", "Pods", "Services"]
```

### Use case:  Route notifications to a given channel based on the Kubernetes Namespace

Currently, you can send notification to non-default channel using [annotation](https://www.botkube.io/usage/#send-notification-to-non-default-channel).
However, you need to apply `botkube.io/channel: <channel_name>` to each K8s object (Pods, Services, etc.) which is cumbersome.

With presented configuration you can do that via dedicated `bindings` property.

**Communicators**
```yaml
communications: # allows to have multiple slacks, or ES configurations
  - name: tenant-workspace
    slack:
      token: 'SLACK_API_TOKEN'
      channels:
        - name: "#dev-team-a"
          bindings:
            notifiers:
              - "team-a"
            executors:
              - "team-a"
        - name: "#dev-team-b"
          bindings:
            notifiers:
              - "team-b"
            executors:
              - "team-b"
        - name: "#admin"
          bindings:
            notifiers:
              - "team-a"
              - "team-b"
            executors:
              - "team-a"
              - "team-b"
```

**Notifiers**
```yaml
notifiers:
  - name: team-a
    kubernetes:
      namespaces:
        include: ["team-a"]
      resources:
        - name: v1/pods
          events:
            - create
            - delete
            - error

  - name: team-b
    kubernetes:
      namespaces:
        include: ["team-b"]
      resources:
        - name: v1/pods
          events:
            - create
            - delete
            - error
```

**Executors**
```yaml
executors:
  - name: team-a
    kubectl:
      namespaces:
        include: ["team-b"]
      commands:
        verbs: ["get", "logs"]
        resources: ["Deployments", "Pods", "Services"]
  - name: team-b
    kubectl:
      namespaces:
        include: ["team-b"]
      commands:
        verbs: ["get", "logs"]
        resources: ["Deployments", "Pods", "Services"]
```

### Use case: Run executor only from a dedicated channel

With presented configuration:
- the `kubectl` command executed from the `"#dev-team-a"` channel can see/mutate objects from the `team-a` Namespace only.
- however, the `kubectl`command  executed from the `"#admin"` channel can see/mutate objects in all Namespaces.

**Communicators**
```yaml
communications: # allows to have multiple slacks, or ES configurations
  - name: tenant-workspace
  slack:
    token: 'SLACK_API_TOKEN'
    # customized notifications
    channels:
      - name: "#dev-team-a"
        bindings:
          executors:
            - kubectl-team-a-ns-access
      - name: "#admin"
        bindings:
          executors:
            - kubectl-full-access
```

**Executors**
```yaml
executors:
  - name: kubectl-full-access
    kubectl:
      enabled: true
      namespaces:
        include: ["@all"]
      commands:
        verbs: ["get", "logs"]
        resources: ["Deployments", "Pods", "Services"]
  - name: kubectl-team-a-ns-access
    kubectl:
      namespaces:
        include: ["team-a"]
      commands:
        verbs: ["get", "logs"]
        resources: ["Deployments", "Pods", "Services"]
```

### Others

If you use the `botkube.io/channel: <channel_name>` annotation, notifications are sent to a given channel even if not authorized.
With a new syntax, we can check if there is a matching notifier binding for a given channel.

## Alternatives

Other approaches that I consider with explanation why I ruled them out.

<details>
  <summary>Discarded alternative</summary>


### Route notifications to a given channel based on the Kubernetes Namespace

#### Annotate Namespace

Allow to set the `botkube.io/channel: <channel_name>` on the Kubernetes Namespace object. As a result, all object's notification from annotated Namespace will be sent to a given channel. Such approach solves the problem partially. You don't need to annotate each object manually in a given Namespace. However, it's still not a part of the BotKube installation. You need to do that manually, or automate that in some way. Additionally, it's decoupled from the BotKube configuration, causing that there are multiple sources of true which you need to analyze to understand to which Namespace the notification will be sent.

#### Top level Namespace property

In the proposed solution, the **namespace** property is defined separately for executors and notifiers. This approach provides fine-grained configuration. You can specify allowed namespace independently, so you can watch for events in all Namespaces but allow `kubectl` usage only in `dev` Namespace.

Unfortunately it doesn't come without any cost. If you want to have a dedicated bindings for Team A, which narrows-down all `notifiers` to `exectors` to the `team-a` Namespace, you need to configure that multiple times. It may be error-prone.
To solve that we can extract the **namespace** property to top level. In this case it will be common for all bindings:

```yaml
communications: # allows to have multiple slacks, or ES configurations
  - name: tenant-workspace
    slack:
      token: 'SLACK_API_TOKEN'
      # customized notifications
      channels:
        - name: "#nodes"
          namespace:
            include: ["team-a"]
          bindings:
            notifiers:
              - "nodes-errors"
            executors:
              - "kubectl-read-only"
              - "helm-full-access"

executors:
  - name: kubectl-read-only
    kubectl:
      commands:
        verbs: ["api-resources", "...", "auth"]
        resources: ["deployments", "..", "nodes"]
  - name: helm-full-access
    helm:
      commands:
        verbs: ["list", "delete", "install"]

notifiers:
  - name: nodes-errors
   kubernetes:
     resources:
       - name: v1/nodes
         events:
           - error
```

</details>

## Consequences

This section described necessary changes if proposal will be accepted.

### Minimum changes

1. The `resources` notifications are moved under `notifiers[].kubernetes[].resources`.
2. Kubectl executor moved under `executors[].kubectl`.
3. The `namespaces.include` and `namespaces.exclude` properties are added to the `kubectl` executor.
4. The `namespaces.include` and `namespaces.exclude` properties are added to `notifiers[].kubernetes[]`.
5. The `resource_config.yaml` and `comm_config.yaml` are merged into one, but you can provide config multiple times. In the same way, as Helm takes the `values.yaml` file. It's up to the user how it will be split.
6. Update documentation about configuration.

### Follow-up changes

1. Change selector for all Namespaces from `all` to `@all`.
2. Add full channel/user indicator - `@` or `#`.
3. Recommendations are merged under notifications.
4. Filters are removed and existing one are moved under `notifiers[].{name}`.
5. Update `@BotKube` commands to reflect new configuration.
6. **Optional**: Add CLI to simplify creating/updating configuration.

### Syntax


1. Notifiers
    <table>
    <tr>
    <td> Before </td> <td> After </td>
    </tr>
    <tr>
    <td>

    ```yaml
    # Notify about K8s events
    resources:
      - name: v1/nodes
      namespaces:
        include:
          - all
      events:
        - error










    # Recommendations about the
    # best practices for the created resource
    recommendations: true







    ```

    </td>
    <td>

    ```yaml
    notifiers:
      - name: default
        kubernetes:
          # New 'namespace' property, allows Namespace restriction
          # It can be overridden in nested level.
          namespace:
            include: ["@all"]
          resources:
            - name: v1/pods
              namespaces: # override top level namespace
                include:
                  - istio-system
              events:
                - error
            - name: networking.istio.io/v1alpha3/VirtualServices
              # uses the default Namespace settings from top level definition.
              events:
                - error
        # Recommendations about the
        # best practices for the created resource
        recommendations:
          image:     # "Checks if 'latest' image tag is used for container image."
            enabled: true
          pod:       # "Checks if labels are missing in the pod specs."
            enabled: true
          ingress:   # "Checks if services and tls secrets used in ingress are available."
            enabled: true
    ```

    </td>
    </tr>
    </table>


2. Executors
    <table>
    <tr>
    <td> Before </td> <td> After </td>
    </tr>
    <tr>
    <td>

    ```yaml
    settings:
      # Cluster name to differentiate incoming messages
      clustername: not-configured
      # Kubectl executor configs
      kubectl:
        enabled: false
        commands:
          verbs: ["api-resources", "...", "auth"]
          resources: ["deployments", "...", "nodes"]
    ```

    </td>
    <td>


    ```yaml
    executors:
      - name: kubectl-read-only # name used for bindings
        kubectl:
          # New 'namespace' property, allows Namespace restriction
          namespaces:
            include:
              - team-a
          commands:
            verbs: ["api-resources", "...", "auth"]
            resources: ["deployments", "..", "nodes"]
    ```

    </td>
    </tr>
    </table>


2. Communications
    <table>
    <tr>
    <td> Before </td> <td> After </td>
    </tr>
    <tr>
    <td>

    ```yaml
    communications:
      # Settings for Slack
      slack:
        enabled: false
        channel: 'SLACK_CHANNEL'
        token: 'SLACK_API_TOKEN'







    ```

    </td>
    <td>


    ```yaml
    communications:
      - name: tenant-b-workspace
        slack:
          enabled: false
          token: 'SLACK_API_TOKEN'
          channels:
            - name: "#team-a"
              bindings:
                notifiers:
                  - "nodes-errors"
                  - "depreacted-api"
                executors:
                  - "kubectl-read-only"
                  - "helm-full-access"
    ```

    </td>
    </tr>
    </table>


## Resources

- [PR that adds profiles to BotKube configuration](https://github.com/infracloudio/botkube/pull/291)
- [Root feature Epic](https://github.com/infracloudio/botkube/issues/596)
